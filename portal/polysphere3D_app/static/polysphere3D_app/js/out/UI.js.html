<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="utf-8">
    <title>JSDoc: Source: UI.js</title>

    <script src="scripts/prettify/prettify.js"> </script>
    <script src="scripts/prettify/lang-css.js"> </script>
    <!--[if lt IE 9]>
      <script src="//html5shiv.googlecode.com/svn/trunk/html5.js"></script>
    <![endif]-->
    <link type="text/css" rel="stylesheet" href="styles/prettify-tomorrow.css">
    <link type="text/css" rel="stylesheet" href="styles/jsdoc-default.css">
</head>

<body>

<div id="main">

    <h1 class="page-title">Source: UI.js</h1>

    



    
    <section>
        <article>
            <pre class="prettyprint source linenums"><code>import Scene, {
    inputShapes,
    inputCoords,
    Colours
} from "../js/scene.js"
import Sol_Scene, {
    sol_inputShapes,
    sol_inputCoords,
    sol_Colours
} from "../js/sol_scene.js"

import Pyramid from '../js/pyramid.js'
import {
    convert_to_pyramid_layers
} from "./ConvertSolutionFormat.js";
import {
    generate_headers,
    populate_problem_matrix3D,
    reduce_problem_matrix
} from "./GenerateProblemMatrix.js";
import {
    create_dicts
} from "./CreateObjects.js";
import {
    solve
} from "./Solver.js";
import {
    shapeStore
} from "./Shapes3D.js";
import resetFirstPlacementCoord from "../js/scene.js";



window.onload = function() {
    const image_names = ['A', 'B', 'C', 'D', 'E', 'F', 'G', 'H', 'I', 'J', 'K', 'L'];

    const imageIds = [
        "shape-1", "shape-2", "shape-3", "shape-4", "shape-5", "shape-6",
        "shape-7", "shape-8", "shape-9", "shape-10", "shape-11", "shape-12"
    ];


    let currentIndex = 0;
    let currentAlphabetIndex = 0;
    let currentImageName = "A"
    currentImage.className = currentImageName

    /**
     * Updates the alphabet container with the current alphabet index.
     */
    function updateAlphabet() {
        const alphabetContainer = document.getElementById('currentAlphabet');
        alphabetContainer.textContent = image_names[currentAlphabetIndex];
    }

    /**
     * Updates the image source, name, class, and rotation angle of the current image.
     */
    function updateImage() {
        currentImage.src = `/static/polysphere3D_app/images/shapes/${imageIds[currentIndex]}.png`;
        currentImageName = image_names[currentIndex]
        console.log(currentImageName)
        currentImage.className = currentImageName
    }

    /**
     * Moves to the previous image in the sequence.
     */
    function previousImage() {
        currentIndex = (currentIndex - 1 + imageIds.length) % imageIds.length;
        updateImage();
        currentAlphabetIndex = (currentAlphabetIndex - 1 + image_names.length) % image_names.length;
        updateAlphabet();
    }

    /**
     * Advances to the next image and updates the UI accordingly.
     */
    function nextImage() {
        currentIndex = (currentIndex + 1) % imageIds.length;
        updateImage();
        currentAlphabetIndex = (currentAlphabetIndex + 1) % image_names.length;
        updateAlphabet();
    }

    const previousImageButton = document.getElementById('previousImageButton');
    previousImageButton.addEventListener('click', previousImage);
    const nextImageButton = document.getElementById('nextImageButton');
    nextImageButton.addEventListener('click', nextImage);


}
/**
 * Represents a worker object.
 * @type {Pyramid}
 */
let worker = new Pyramid(5, 1);
/**
 * Represents a sol_worker object.
 * @type {Pyramid}
 */
let sol_worker = new Pyramid(5, 1);

let scene = new Scene();
let sol_scene = new Sol_Scene();
const FPS = 30;
let uiTimer = null;
let visibilityStates = [true, true, true, true, true];

/**
 * Creates a timer that repeatedly calls the specified function at a given frame rate.
 * @param {Function} func - The function to be called repeatedly by the timer.
 */
function createTimer(func) {
    if (uiTimer) {
        clearInterval(uiTimer);
        uiTimer = null;
    }

    uiTimer = setInterval(() => {
        func();
    }, 1000 / FPS);
}


/**
 * Renders the pyramid by iterating through the layers of spheres and updating their positions and colors.
 */
function renderPyramid() {
    for (let i = 0; i &lt; worker.layers.length; i++) {
        const spheres = worker.layers[i].matrix;
        for (let x = 0; x &lt; worker.layers[i].size; x++) {
            for (let y = 0; y &lt; worker.layers[i].size; y++) {
                let pos = spheres[x][y].pos;
                let color = spheres[x][y].color;

                if (!spheres[x][y].userData) {
                    spheres[x][y].userData = scene.createSphere(
                        pos[0],
                        pos[1],
                        pos[2],
                        color,
                        worker.radius()
                    );
                    scene.add(spheres[x][y].userData);
                } else {
                    spheres[x][y].userData.material.color.set(color);
                    spheres[x][y].userData.material.specular.set(color);
                }
            }
        }
    }
}

/**
 * Renders the solution pyramid by updating the positions and colors of the spheres in the scene.
 */
function sol_renderPyramid() {
    for (let i = 0; i &lt; sol_worker.layers.length; i++) {
        const spheres = sol_worker.layers[i].matrix;
        for (let x = 0; x &lt; sol_worker.layers[i].size; x++) {
            for (let y = 0; y &lt; sol_worker.layers[i].size; y++) {
                let pos = spheres[x][y].pos;
                let color = spheres[x][y].color;

                if (!spheres[x][y].userData) {
                    spheres[x][y].userData = sol_scene.createSphere(
                        pos[0],
                        pos[1],
                        pos[2],
                        color,
                        sol_worker.radius()
                    );
                    sol_scene.add(spheres[x][y].userData);
                } else {
                    spheres[x][y].userData.material.color.set(color);
                    spheres[x][y].userData.material.specular.set(color);
                }
            }
        }
    }
}

/**
 * Updates the visibility of a layer and its spheres.
 * @param {number} idx - The index of the layer.
 * @param {boolean} v - The new visibility state.
 */
function layerVisible(idx, v) {
    console.log("Layer Visible", idx, v)
    // Updates the visibilityStates to match change
    visibilityStates[idx - 1] = v
    let layer = worker.getLayer(idx);
    const spheres = layer.matrix;
    for (let x = 0; x &lt; layer.size; x++) {
        for (let y = 0; y &lt; layer.size; y++) {
            if (spheres[x][y].userData) {
                spheres[x][y].userData.visible = v;
                spheres[x][y].visible = v;
                spheres[x][y].userData.needsUpdate = true;
            }
        }
    }
}

/**
 * Updates the visibility of a layer in the solution pyramid object.
 * 
 * @param {number} idx - The index of the layer.
 * @param {boolean} v - The new visibility state of the layer.
 */
function sol_layerVisible(idx, v) {
    console.log("Layer Visible", idx, v)
    // Updates the visibilityStates to match change
    visibilityStates[idx - 1] = v
    //console.log("New States", visibilityStates)
    let layer = sol_worker.getLayer(idx);
    const spheres = layer.matrix;
    for (let x = 0; x &lt; layer.size; x++) {
        for (let y = 0; y &lt; layer.size; y++) {
            if (spheres[x][y].userData) {
                spheres[x][y].userData.visible = v;
                spheres[x][y].visible = v;
                spheres[x][y].userData.needsUpdate = true;
                //console.log("?");
            }
        }
    }
}

let input;
let input_shapes;
let input_squares;
let problem_mat;
let problem_def;
let headers;
let dicts;

const canvas = document.getElementById('panel');
const sol_canvas = document.getElementById('c');
const NextButton = document.getElementById('onNextButtonClick');
const PrevButton = document.getElementById('onPrevButtonClick');
const ClearButton = document.getElementById('onClearButtonClick');
const StopButton = document.getElementById('onStopButtonClick');
const scount = document.getElementById('solutionCount');
const solveButton = document.getElementById('onSolveButtonClick');
solveButton.addEventListener('click', onSolveButton);
NextButton.addEventListener('click', onNextButton);
PrevButton.addEventListener('click', onPrevButton);

ClearButton.addEventListener('click', onClearButton);
StopButton.addEventListener('click', onStopButton);

const layerCheckboxes = [];
const sol_layerCheckboxes = [];
const toggle = document.getElementById('toggleButton');
const toggleDiv = document.getElementById('SolContainer');
const layer_pyramid = document.getElementById('Levels');

toggleButton.addEventListener('click', function() {
    // Prevent the default form submission behavior
    event.preventDefault();

    // Toggle the display property of the div
    if (toggleDiv.style.display === 'none' || toggleDiv.style.display === '') {
        toggleDiv.style.display = 'flex';
        toggleButton.textContent = 'Hide';
        layer_pyramid.style.display = 'flex';

    } else {
        toggleDiv.style.display = 'none';
        layer_pyramid.style.display = 'none';
        toggleButton.textContent = 'Show Solutions';

    }
});



for (let i = 1; i &lt;= 5; i++) {
    const checkbox = document.getElementById('l' + i);
    const sol_checkbox = document.getElementById('ls' + i);
    checkbox.addEventListener('change', (event) => {
        layerVisible(i, event.target.checked);
    });
    sol_checkbox.addEventListener('change', (event) => {
        sol_layerVisible(i, event.target.checked);
    });
    const label = document.getElementById('l' + i + 'sLabel');
    const sol_label = document.getElementById('ls' + i + 'Label');
    console.log(checkbox, label);
    layerCheckboxes.push(checkbox, label);
    sol_layerCheckboxes.push(sol_checkbox, sol_label);
}



const state = createState();

/**
 * Creates a new state object.
 * @returns {Object} The newly created state object.
 */
function createState() {
    return {
        stopExecution: false,
        solutionCount: 0,
        solutions: [],
        isFourLevel: false,
        currentIndex: 0,
    };
}

/**
 * Handles the event when the solve button is clicked.
 */
function onSolveButton() {
    state.solutions = []
    var allSolutions = [];
    let solutionCount = 0;
    let solutions = [];


    const input_shapes = inputShapes.get();
    const input_squares = inputCoords.get();

    // If incorrect number of spheres for shape, abort.
    if (!checkInput(input_shapes, input_squares)) {
        return;
    }


    const problem_mat = populate_problem_matrix3D();
    const problem_def = reduce_problem_matrix(problem_mat, generate_headers(problem_mat), input_shapes, input_squares, state.isFourLevel);
    const updatedProblemMat = problem_def[0];
    const headers = problem_def[1];

    console.log(updatedProblemMat);
    console.log(headers);

    const dicts = create_dicts(updatedProblemMat, headers, state.isFourLevel);

    console.log(Object.keys(dicts[0]).length);
    console.log(dicts[0]);
    console.log(dicts[1]);
    console.log(headers);

    const ret = solve(dicts[0], dicts[1], [], state.isFourLevel, headers);
    let cnt = 0;

    const uiTimer = createTimer(() => {
        const arr = ret.next().value;
        if (arr == undefined) {
            console.log('done');
            if(cnt &lt; 1){
                scount.textContent = "No solutions found!";
            }
            onStopButton();
            return;
        }

        console.log(arr);

        cnt++;
        scount.textContent = "Number of solutions: " + cnt;
        // Push the current pyramid_layers into the array

        const pyramid_layers = convert_to_pyramid_layers(arr, updatedProblemMat, headers, input_shapes, input_squares);
        state.solutions = [...state.solutions, pyramid_layers];
        allSolutions.push(pyramid_layers); // All solutions
        console.log("Solve", pyramid_layers)
        sol_drawPosition(pyramid_layers);
    });
}

/**
 * Clears the UI and resets the state.
 */
function onClearButton() {
    scount.textContent = "Number of solutions: 0"
    state.solutions = []
    inputShapes.clear();
    inputCoords.clear();
    new resetFirstPlacementCoord()

    // Set pyramid to empty and render empty pyramid
    const empty_position = new Array(5);
    for (let i = 0; i &lt; 5; i++) {
        empty_position[i] = new Array(5 - i);
        empty_position[i].fill(0);
    }
    for (let layer = 0; layer &lt; 5; layer++) {
        for (let row = 0; row &lt; 5 - layer; row++) {
            empty_position[layer][row] = new Array(5 - layer);
            empty_position[layer][row].fill(0);
        }
    }
    drawPosition(empty_position);
    sol_drawPosition(empty_position);
}

/**
 * Draws the position on the pyramid.
 * 
 * @param {Array&lt;Array&lt;Array&lt;string>>>} position - The position to be drawn.
 */
function drawPosition(position) {

    for (let layer = 0; layer &lt; position.length; layer++) {
        for (let i = 0; i &lt; position[layer].length; i++) {
            for (let j = 0; j &lt; position[layer].length; j++) {
                if (["A", "B", "C", "D", "E", "F", "G", "H", "I", "J", "K", "L"].indexOf(position[layer][i][j]) !== -1) {
                    // Set to shape colour
                    worker.getLayer(5 - layer).set(i, j, Colours[position[layer][i][j]]);

                } else {
                    // Set to black to indicate empty
                    worker.getLayer(5 - layer).set(i, j, 0x999999);

                }
            }
        }
    }
    renderPyramid();
}

/**
 * Draws the position on the solution pyramid.
 * 
 * @param {Array&lt;Array&lt;Array&lt;string>>>} position - The position to be drawn on the pyramid.
 * @returns {void}
 */
function sol_drawPosition(position) {

    for (let layer = 0; layer &lt; position.length; layer++) {
        for (let i = 0; i &lt; position[layer].length; i++) {
            for (let j = 0; j &lt; position[layer].length; j++) {
                if (["A", "B", "C", "D", "E", "F", "G", "H", "I", "J", "K", "L"].indexOf(position[layer][i][j]) !== -1) {
                    // Set to shape colour
                    sol_worker.getLayer(5 - layer).set(i, j, sol_Colours[position[layer][i][j]]);

                } else {
                    // Set to black to indicate empty
                   sol_worker.getLayer(5 - layer).set(i, j, 0x999999);

                }
            }
        }
    }
    sol_renderPyramid();
}

/**
 * Checks if the number of spheres for each shape matches the number of coordinates provided.
 * @param {string[]} shapes - An array of shape names.
 * @param {number[][]} coords - An array of coordinate arrays, where each array represents the coordinates for a shape.
 * @returns {boolean} - Returns true if the number of spheres for each shape matches the number of coordinates, otherwise false.
 */
function checkInput(shapes, coords) {
    console.log("Shapes:", shapes, "Coords:", coords)
    for (let i = 0; i &lt; shapes.length; i++) {
        if (shapeStore[shapes[i]].layout.length !== coords[i].length) {
            // Wrong number of spheres for shape, abort.
            return false;
        }
    }
    return true;
}

/**
 * Handles the click event of the next button.
 * Traverses to the next solution in the state's solutions array and calls sol_drawPosition to draw it.
 */
function onNextButton() {
    console.log("Clicked next");
    if (state.currentIndex &lt; state.solutions.length - 1) {
        state.currentIndex++;
        sol_drawPosition(state.solutions[state.currentIndex]);
    }
}

/**
 * Handles the click event of the "Prev" button.
 * Traverses to the previous solution in the state's solutions array and calls sol_drawPosition to draw it.
 */
function onPrevButton() {
    console.log("Clicked Prev");
    if (state.currentIndex > 0) {
        state.currentIndex--;
        sol_drawPosition(state.solutions[state.currentIndex]);
    }
}
/**
 * Stops the execution and clears the interval timer.
 */
function onStopButton() {
    let stopExecution = true;
    clearInterval(uiTimer);
    uiTimer = null;
}

/**
 * Initializes the component and sets up the scene and pyramid rendering.
 */
function componentDidMount() {
    scene.init(panel);
    sol_scene.sol_init(c);
    renderPyramid();
    sol_renderPyramid();
}

/**
 * Cleans up resources before the component is unmounted.
 */
function componentWillUnmount() {
    scene.dispose();
    sol_scene.dispose();
}

scene.init(panel);
sol_scene.sol_init(c);
renderPyramid();
sol_renderPyramid();

export {
    worker,
    sol_worker
};
window.worker = worker;
window.sol_worker = sol_worker;</code></pre>
        </article>
    </section>




</div>

<nav>
    <h2><a href="index.html">Home</a></h2><h3>Classes</h3><ul><li><a href="AnimationObjectGroup.html">AnimationObjectGroup</a></li><li><a href="BooleanKeyframeTrack.html">BooleanKeyframeTrack</a></li><li><a href="CameraHelper.html">CameraHelper</a></li><li><a href="ColorKeyframeTrack.html">ColorKeyframeTrack</a></li><li><a href="CompressedTextureLoader.html">CompressedTextureLoader</a></li><li><a href="CubicInterpolant.html">CubicInterpolant</a></li><li><a href="Curve.html">Curve</a></li><li><a href="Cylindrical.html">Cylindrical</a></li><li><a href="DataTextureLoader.html">DataTextureLoader</a></li><li><a href="DiscreteInterpolant.html">DiscreteInterpolant</a></li><li><a href="EventDispatcher.html">EventDispatcher</a></li><li><a href="ExtrudeGeometry.html">ExtrudeGeometry</a></li><li><a href="Interpolant.html">Interpolant</a></li><li><a href="NumberKeyframeTrack.html">NumberKeyframeTrack</a></li><li><a href="OrbitControl.html">OrbitControl</a></li><li><a href="PMREMGenerator.html">PMREMGenerator</a></li><li><a href="Pyramid.html">Pyramid</a></li><li><a href="PyramidLayer.html">PyramidLayer</a></li><li><a href="QuaternionKeyframeTrack.html">QuaternionKeyframeTrack</a></li><li><a href="QuaternionLinearInterpolant.html">QuaternionLinearInterpolant</a></li><li><a href="Shape3D.html">Shape3D</a></li><li><a href="Spherical.html">Spherical</a></li><li><a href="SphericalHarmonics3.html">SphericalHarmonics3</a></li><li><a href="StringKeyframeTrack.html">StringKeyframeTrack</a></li><li><a href="VectorKeyframeTrack.html">VectorKeyframeTrack</a></li><li><a href="module.exports.html">exports</a></li><li><a href="scene.html">scene</a></li></ul><h3>Global</h3><ul><li><a href="global.html#CatmullRom">CatmullRom</a></li><li><a href="global.html#Earcut">Earcut</a></li><li><a href="global.html#REVISION">REVISION</a></li><li><a href="global.html#STEP">STEP</a></li><li><a href="global.html#UniformsLib">UniformsLib</a></li><li><a href="global.html#add">add</a></li><li><a href="global.html#add_row_for_diags_if_valid">add_row_for_diags_if_valid</a></li><li><a href="global.html#add_rows_for_shape_in_horizontal_and_vertical_slices">add_rows_for_shape_in_horizontal_and_vertical_slices</a></li><li><a href="global.html#calculatePosition">calculatePosition</a></li><li><a href="global.html#camera">camera</a></li><li><a href="global.html#checkInput">checkInput</a></li><li><a href="global.html#cloneUniforms">cloneUniforms</a></li><li><a href="global.html#componentDidMount">componentDidMount</a></li><li><a href="global.html#componentWillUnmount">componentWillUnmount</a></li><li><a href="global.html#convert_rect_coords_to_diags">convert_rect_coords_to_diags</a></li><li><a href="global.html#convert_to_pyramid_layers">convert_to_pyramid_layers</a></li><li><a href="global.html#coord_to_col">coord_to_col</a></li><li><a href="global.html#cover">cover</a></li><li><a href="global.html#createSphere">createSphere</a></li><li><a href="global.html#createState">createState</a></li><li><a href="global.html#createTimer">createTimer</a></li><li><a href="global.html#create_dicts">create_dicts</a></li><li><a href="global.html#dispose">dispose</a></li><li><a href="global.html#disposeSphere">disposeSphere</a></li><li><a href="global.html#dlx">dlx</a></li><li><a href="global.html#drawPosition">drawPosition</a></li><li><a href="global.html#emptyTexture">emptyTexture</a></li><li><a href="global.html#generate_headers">generate_headers</a></li><li><a href="global.html#get_diag_slices">get_diag_slices</a></li><li><a href="global.html#get_horizontal_slices">get_horizontal_slices</a></li><li><a href="global.html#globalLight">globalLight</a></li><li><a href="global.html#helper">helper</a></li><li><a href="global.html#init">init</a></li><li><a href="global.html#initScene">initScene</a></li><li><a href="global.html#initialiseScene">initialiseScene</a></li><li><a href="global.html#layerVisible">layerVisible</a></li><li><a href="global.html#light">light</a></li><li><a href="global.html#onClearButton">onClearButton</a></li><li><a href="global.html#onNextButton">onNextButton</a></li><li><a href="global.html#onPrevButton">onPrevButton</a></li><li><a href="global.html#onSolveButton">onSolveButton</a></li><li><a href="global.html#onStopButton">onStopButton</a></li><li><a href="global.html#populate_problem_matrix3D">populate_problem_matrix3D</a></li><li><a href="global.html#reduce_problem_matrix">reduce_problem_matrix</a></li><li><a href="global.html#renderPyramid">renderPyramid</a></li><li><a href="global.html#renderer">renderer</a></li><li><a href="global.html#shape_cols">shape_cols</a></li><li><a href="global.html#shape_to_row">shape_to_row</a></li><li><a href="global.html#sol_drawPosition">sol_drawPosition</a></li><li><a href="global.html#sol_init">sol_init</a></li><li><a href="global.html#sol_layerVisible">sol_layerVisible</a></li><li><a href="global.html#sol_renderPyramid">sol_renderPyramid</a></li><li><a href="global.html#sol_scene">sol_scene</a></li><li><a href="global.html#sol_worker">sol_worker</a></li><li><a href="global.html#solve">solve</a></li><li><a href="global.html#uncover">uncover</a></li><li><a href="global.html#worker">worker</a></li></ul>
</nav>

<br class="clear">

<footer>
    Documentation generated by <a href="https://github.com/jsdoc/jsdoc">JSDoc 4.0.2</a> on Thu Dec 14 2023 17:11:33 GMT+0000 (Greenwich Mean Time)
</footer>

<script> prettyPrint(); </script>
<script src="scripts/linenumber.js"> </script>
</body>
</html>
